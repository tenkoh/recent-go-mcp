[
  {
    "version": "1.23",
    "release_date": "2024-08-13T00:00:00Z",
    "summary": "Go 1.23 introduces powerful iterator support, major timer improvements, new packages, and enhanced standard library with breaking changes for modern coding.",
    "changes": [
      {
        "category": "language",
        "description": "Range-over-func: for-range loops can now iterate over iterator functions with signatures func(func() bool), func(func(K) bool), or func(func(K, V) bool)",
        "impact": "new"
      },
      {
        "category": "runtime",
        "description": "Timer/Ticker major improvements: immediate GC of unused timers, unbuffered channels, reduced CPU overhead",
        "impact": "performance"
      },
      {
        "category": "runtime",
        "description": "Profile Guided Optimization (PGO) build time overhead significantly reduced",
        "impact": "performance"
      },
      {
        "category": "language",
        "description": "Generic type aliases preview support (GOEXPERIMENT=aliastypeparams)",
        "impact": "new"
      },
      {
        "category": "platform",
        "description": "macOS minimum version increased to 11+ (breaking change for older macOS)",
        "impact": "breaking"
      },
      {
        "category": "toolchain",
        "description": "New stdversion analyzer in go vet detects Go version requirements",
        "impact": "new"
      },
      {
        "category": "toolchain",
        "description": "Optional telemetry collection for Go toolchain usage analytics",
        "impact": "new"
      }
    ],
    "packages": {
      "iter": [
        {
          "description": "New package providing iterator type definitions for range-over-func",
          "impact": "new",
          "example": "type Seq[V any] func(yield func(V) bool)\ntype Seq2[K, V any] func(yield func(K, V) bool)"
        }
      ],
      "unique": [
        {
          "function": "Make",
          "description": "New package for value canonicalization/interning to reduce memory usage",
          "impact": "new",
          "example": "handle := unique.Make(\"string\")\n// Multiple calls with same value return same handle"
        }
      ],
      "structs": [
        {
          "description": "New package for struct field layout control and analysis",
          "impact": "new",
          "example": "// Provides control over struct memory layout"
        }
      ],
      "slices": [
        {
          "function": "All",
          "description": "Returns iterator over slice indexes and values",
          "impact": "new",
          "example": "for i, v := range slices.All(slice) { ... }"
        },
        {
          "function": "Values",
          "description": "Returns iterator over slice values only",
          "impact": "new",
          "example": "for v := range slices.Values(slice) { ... }"
        },
        {
          "function": "Backward",
          "description": "Returns iterator over slice elements in reverse order",
          "impact": "new",
          "example": "for i, v := range slices.Backward(slice) { ... }"
        },
        {
          "function": "Collect",
          "description": "Converts iterator to slice",
          "impact": "new",
          "example": "result := slices.Collect(iterator)"
        },
        {
          "function": "AppendSeq",
          "description": "Appends values from iterator to slice",
          "impact": "new",
          "example": "result := slices.AppendSeq(slice, iterator)"
        },
        {
          "function": "Sorted",
          "description": "Collects values from iterator into sorted slice",
          "impact": "new",
          "example": "sorted := slices.Sorted(iterator)"
        },
        {
          "function": "SortedFunc",
          "description": "Collects values from iterator into slice sorted by custom function",
          "impact": "new",
          "example": "sorted := slices.SortedFunc(iterator, cmp)"
        },
        {
          "function": "SortedStableFunc",
          "description": "Stable sort version of SortedFunc",
          "impact": "new",
          "example": "sorted := slices.SortedStableFunc(iterator, cmp)"
        },
        {
          "function": "Chunk",
          "description": "Returns iterator over consecutive sub-slices of up to n elements",
          "impact": "new",
          "example": "for chunk := range slices.Chunk(slice, 3) { ... }"
        }
      ],
      "maps": [
        {
          "function": "All",
          "description": "Returns iterator over key-value pairs",
          "impact": "new",
          "example": "for k, v := range maps.All(m) { ... }"
        },
        {
          "function": "Keys",
          "description": "Returns iterator over map keys",
          "impact": "new",
          "example": "for k := range maps.Keys(m) { ... }"
        },
        {
          "function": "Values",
          "description": "Returns iterator over map values",
          "impact": "new",
          "example": "for v := range maps.Values(m) { ... }"
        },
        {
          "function": "Insert",
          "description": "Adds key-value pairs from iterator to map",
          "impact": "new",
          "example": "maps.Insert(m, iterator)"
        },
        {
          "function": "Collect",
          "description": "Creates new map from iterator of key-value pairs",
          "impact": "new",
          "example": "newMap := maps.Collect(iterator)"
        }
      ],
      "time": [
        {
          "description": "Timer and Ticker performance improvements - unused timers are immediately garbage collected",
          "impact": "performance",
          "example": "// Timers now use unbuffered channels and have reduced overhead"
        },
        {
          "function": "Timer.Reset",
          "description": "Behavior change: Reset on stopped/expired timer now returns false (breaking change)",
          "impact": "breaking",
          "example": "// Old code may need adjustment for timer reset logic"
        }
      ],
      "crypto/tls": [
        {
          "description": "Encrypted Client Hello (ECH) support for enhanced privacy",
          "impact": "new",
          "example": "// Automatic ECH support when available"
        },
        {
          "description": "Post-quantum key exchange mechanism support (experimental)",
          "impact": "new",
          "example": "// Future-proofing against quantum computing threats"
        }
      ],
      "net": [
        {
          "description": "Enhanced TCP keep-alive configuration with more granular control",
          "impact": "enhancement",
          "example": "// Better control over connection keep-alive behavior"
        }
      ],
      "net/http": [
        {
          "description": "Improved cookie parsing and handling for better HTTP compliance",
          "impact": "enhancement",
          "example": "// More robust cookie parsing edge cases"
        },
        {
          "function": "ServeFileFS",
          "description": "Enhanced file serving from filesystem with better security",
          "impact": "enhancement",
          "example": "http.ServeFileFS(w, r, fsys, name)"
        }
      ],
      "cmp": [
        {
          "function": "Or",
          "description": "Returns first non-zero value or zero value of type",
          "impact": "new",
          "example": "result := cmp.Or(a, b, c) // first non-zero value"
        }
      ],
      "go/version": [
        {
          "function": "Compare",
          "description": "Compares Go version strings",
          "impact": "new",
          "example": "if version.Compare(\"go1.22\", \"go1.21\") > 0 { ... }"
        },
        {
          "function": "IsValid",
          "description": "Reports whether version string is valid",
          "impact": "new",
          "example": "if version.IsValid(\"go1.23\") { ... }"
        },
        {
          "function": "Lang",
          "description": "Returns Go language version from release version",
          "impact": "new",
          "example": "lang := version.Lang(\"go1.23.1\") // returns \"go1.23\""
        }
      ]
    }
  },
  {
    "version": "1.22",
    "release_date": "2024-02-06T00:00:00Z",
    "summary": "Go 1.22 introduces revolutionary for-range improvements, math/rand/v2, enhanced HTTP routing, and significant performance gains.",
    "changes": [
      {
        "category": "language",
        "description": "For-range over integers: range over integer values directly (e.g., for i := range 10)",
        "impact": "new"
      },
      {
        "category": "language",
        "description": "For-loop variable semantics: each iteration creates new variables, preventing accidental sharing bugs",
        "impact": "enhancement"
      },
      {
        "category": "language",
        "description": "Experimental range-over-function iterators for future iterator support",
        "impact": "new"
      },
      {
        "category": "runtime",
        "description": "Garbage collection metadata optimization providing 1-3% CPU performance improvement",
        "impact": "performance"
      },
      {
        "category": "runtime",
        "description": "Profile-guided optimization (PGO) improvements with better devirtualization and inlining",
        "impact": "performance"
      },
      {
        "category": "toolchain",
        "description": "go work vendor command for vendoring dependencies in workspace mode",
        "impact": "new"
      },
      {
        "category": "toolchain",
        "description": "Enhanced tracing and profiling capabilities",
        "impact": "enhancement"
      }
    ],
    "packages": {
      "math/rand/v2": [
        {
          "description": "First v2 standard library package with modern random number generation",
          "impact": "new",
          "example": "// Automatically seeded, no need for manual seeding"
        },
        {
          "function": "N",
          "description": "Generic random number generator - returns random value in [0, n)",
          "impact": "new",
          "example": "rand.N(100) // returns random int in [0, 100)\nrand.N(uint64(1000)) // works with any integer type"
        },
        {
          "function": "IntN",
          "description": "Returns random int in [0, n) - replaces old Intn",
          "impact": "new",
          "example": "num := rand.IntN(100)"
        },
        {
          "function": "Uint32N",
          "description": "Returns random uint32 in [0, n)",
          "impact": "new",
          "example": "num := rand.Uint32N(1000)"
        },
        {
          "function": "Uint64N",
          "description": "Returns random uint64 in [0, n)",
          "impact": "new",
          "example": "num := rand.Uint64N(1000000)"
        },
        {
          "description": "ChaCha8 and PCG generators replace older algorithms for better randomness",
          "impact": "enhancement",
          "example": "// More cryptographically secure random generation"
        }
      ],
      "net/http": [
        {
          "function": "ServeMux",
          "description": "Revolutionary routing with method-specific patterns and wildcard support",
          "impact": "enhancement",
          "example": "mux.HandleFunc(\"GET /users/{id}\", getUser)\nmux.HandleFunc(\"POST /users\", createUser)\nmux.HandleFunc(\"/files/{path...}\", serveFiles)"
        },
        {
          "function": "Request.PathValue",
          "description": "Extract path parameters from wildcard routes",
          "impact": "new",
          "example": "userID := r.PathValue(\"id\")\nfilePath := r.PathValue(\"path\")"
        },
        {
          "description": "Method-specific routing enables RESTful patterns without external routers",
          "impact": "enhancement",
          "example": "// GET /api/users and POST /api/users can have different handlers"
        },
        {
          "description": "Wildcard path matching with {name} and {name...} syntax",
          "impact": "new",
          "example": "// /users/{id} matches /users/123\n// /files/{path...} matches /files/docs/readme.txt"
        },
        {
          "description": "GODEBUG httpmuxgo121=1 available for backwards compatibility",
          "impact": "breaking",
          "example": "// Some existing routing patterns may need adjustment"
        }
      ],
      "slices": [
        {
          "function": "Concat",
          "description": "Efficiently concatenate multiple slices of the same type",
          "impact": "new",
          "example": "result := slices.Concat(slice1, slice2, slice3)\n// More efficient than append chains"
        },
        {
          "function": "Insert",
          "description": "Insert elements at specific index",
          "impact": "new",
          "example": "result := slices.Insert(slice, index, values...)"
        },
        {
          "function": "Delete",
          "description": "Delete elements from slice by index range",
          "impact": "new",
          "example": "result := slices.Delete(slice, start, end)"
        },
        {
          "function": "Replace",
          "description": "Replace slice elements with new values",
          "impact": "new",
          "example": "result := slices.Replace(slice, start, end, values...)"
        }
      ],
      "maps": [
        {
          "function": "Clone",
          "description": "Create shallow copy of map",
          "impact": "new",
          "example": "newMap := maps.Clone(originalMap)"
        },
        {
          "function": "Copy",
          "description": "Copy key-value pairs from one map to another",
          "impact": "new",
          "example": "maps.Copy(dst, src) // copies src entries to dst"
        },
        {
          "function": "DeleteFunc",
          "description": "Delete map entries based on predicate function",
          "impact": "new",
          "example": "maps.DeleteFunc(m, func(k, v) bool { return v < 0 })"
        },
        {
          "function": "Equal",
          "description": "Compare two maps for equality",
          "impact": "new",
          "example": "if maps.Equal(map1, map2) { ... }"
        },
        {
          "function": "EqualFunc",
          "description": "Compare maps with custom equality function",
          "impact": "new",
          "example": "maps.EqualFunc(m1, m2, func(v1, v2 Type) bool { ... })"
        }
      ],
      "go/version": [
        {
          "function": "Compare",
          "description": "New package for Go version string comparison",
          "impact": "new",
          "example": "if version.Compare(\"go1.22\", \"go1.21\") > 0 { ... }"
        },
        {
          "function": "IsValid",
          "description": "Validate Go version string format",
          "impact": "new",
          "example": "if version.IsValid(\"go1.22.1\") { ... }"
        },
        {
          "function": "Lang",
          "description": "Extract language version from release version",
          "impact": "new",
          "example": "lang := version.Lang(\"go1.22.1\") // returns \"go1.22\""
        }
      ],
      "testing/slogtest": [
        {
          "description": "New package for testing structured logging with slog",
          "impact": "new",
          "example": "// Enhanced testing utilities for structured logging"
        }
      ],
      "log/slog": [
        {
          "function": "SetLogLoggerLevel",
          "description": "Set minimum level for default logger",
          "impact": "new",
          "example": "slog.SetLogLoggerLevel(slog.LevelDebug)"
        },
        {
          "description": "Performance improvements for high-throughput logging",
          "impact": "performance",
          "example": "// Faster structured logging with reduced allocations"
        }
      ],
      "encoding/json": [
        {
          "description": "Improved performance for JSON marshaling/unmarshaling",
          "impact": "performance",
          "example": "// 5-10% faster JSON processing"
        }
      ],
      "crypto/tls": [
        {
          "description": "TLS 1.3 performance improvements and better cipher suite selection",
          "impact": "performance",
          "example": "// More efficient TLS handshakes"
        }
      ],
      "cmp": [
        {
          "function": "Compare",
          "description": "Generic comparison function for ordered types",
          "impact": "new",
          "example": "result := cmp.Compare(a, b) // returns -1, 0, or 1"
        },
        {
          "function": "Less",
          "description": "Generic less-than comparison",
          "impact": "new",
          "example": "if cmp.Less(a, b) { ... }"
        }
      ]
    }
  },
  {
    "version": "1.21",
    "release_date": "2023-08-08T00:00:00Z",
    "summary": "Go 1.21 introduces revolutionary built-in functions, comprehensive slice/map packages, structured logging, WebAssembly improvements, and production-ready PGO.",
    "changes": [
      {
        "category": "language",
        "description": "Three new built-in functions: min, max, and clear for common operations",
        "impact": "new"
      },
      {
        "category": "language",
        "description": "Enhanced type inference for generics with better type argument inference",
        "impact": "enhancement"
      },
      {
        "category": "runtime",
        "description": "Profile-guided optimization (PGO) is now production-ready with significant performance gains",
        "impact": "performance"
      },
      {
        "category": "runtime",
        "description": "Garbage collection improvements potentially reducing tail latency by up to 40%",
        "impact": "performance"
      },
      {
        "category": "runtime",
        "description": "WebAssembly System Interface (WASI) Preview 1 support (experimental)",
        "impact": "new"
      },
      {
        "category": "runtime",
        "description": "New go:wasmimport directive for importing WebAssembly host functions",
        "impact": "new"
      },
      {
        "category": "toolchain",
        "description": "Build speed improvements up to 6% faster compilation",
        "impact": "performance"
      },
      {
        "category": "platform",
        "description": "Minimum OS requirements updated: macOS 10.15+, Windows 10/Server 2016+",
        "impact": "breaking"
      }
    ],
    "packages": {
      "builtin": [
        {
          "function": "min",
          "description": "Returns the minimum value among comparable arguments (variadic)",
          "impact": "new",
          "example": "min(1, 2, 3) // returns 1\nmin(\"apple\", \"banana\") // returns \"apple\""
        },
        {
          "function": "max",
          "description": "Returns the maximum value among comparable arguments (variadic)",
          "impact": "new",
          "example": "max(1, 2, 3) // returns 3\nmax(\"apple\", \"banana\") // returns \"banana\""
        },
        {
          "function": "clear",
          "description": "Deletes all elements from maps or zeroes all elements of slices",
          "impact": "new",
          "example": "clear(myMap) // deletes all map entries\nclear(mySlice) // zeros all slice elements but keeps length"
        }
      ],
      "slices": [
        {
          "function": "Sort",
          "description": "New package providing comprehensive slice operations - sorts slice in ascending order",
          "impact": "new",
          "example": "slices.Sort([]int{3, 1, 2}) // [1, 2, 3]"
        },
        {
          "function": "SortFunc",
          "description": "Sorts slice with custom comparison function",
          "impact": "new",
          "example": "slices.SortFunc(slice, func(a, b T) int { return cmp.Compare(a, b) })"
        },
        {
          "function": "BinarySearch",
          "description": "Searches for target in sorted slice using binary search",
          "impact": "new",
          "example": "idx, found := slices.BinarySearch(sortedSlice, target)"
        },
        {
          "function": "Contains",
          "description": "Reports whether value is present in slice",
          "impact": "new",
          "example": "if slices.Contains(slice, value) { ... }"
        },
        {
          "function": "Index",
          "description": "Returns first index of value in slice, -1 if not found",
          "impact": "new",
          "example": "idx := slices.Index(slice, value)"
        },
        {
          "function": "Equal",
          "description": "Reports whether two slices are equal (same length and elements)",
          "impact": "new",
          "example": "if slices.Equal(slice1, slice2) { ... }"
        },
        {
          "function": "Compare",
          "description": "Compares two slices lexicographically",
          "impact": "new",
          "example": "result := slices.Compare(slice1, slice2) // -1, 0, or 1"
        },
        {
          "function": "Clone",
          "description": "Returns shallow copy of slice",
          "impact": "new",
          "example": "copy := slices.Clone(original)"
        },
        {
          "function": "Compact",
          "description": "Removes consecutive duplicate elements",
          "impact": "new",
          "example": "unique := slices.Compact([]int{1, 1, 2, 3, 3}) // [1, 2, 3]"
        },
        {
          "function": "Delete",
          "description": "Removes elements from slice by index range",
          "impact": "new",
          "example": "result := slices.Delete(slice, 2, 4) // removes elements [2:4]"
        },
        {
          "function": "Insert",
          "description": "Inserts values at specified index",
          "impact": "new",
          "example": "result := slices.Insert(slice, 2, values...)"
        },
        {
          "function": "Replace",
          "description": "Replaces elements in range with new values",
          "impact": "new",
          "example": "result := slices.Replace(slice, 1, 3, newValues...)"
        },
        {
          "function": "Reverse",
          "description": "Reverses elements of slice in place",
          "impact": "new",
          "example": "slices.Reverse(slice)"
        }
      ],
      "maps": [
        {
          "function": "Clone",
          "description": "New package for map operations - creates shallow copy of map",
          "impact": "new",
          "example": "newMap := maps.Clone(originalMap)"
        },
        {
          "function": "Copy",
          "description": "Copies key-value pairs from source to destination map",
          "impact": "new",
          "example": "maps.Copy(dst, src) // copies src entries to dst"
        },
        {
          "function": "DeleteFunc",
          "description": "Deletes map entries where function returns true",
          "impact": "new",
          "example": "maps.DeleteFunc(m, func(k, v) bool { return v < 0 })"
        },
        {
          "function": "Equal",
          "description": "Reports whether two maps have same key-value pairs",
          "impact": "new",
          "example": "if maps.Equal(map1, map2) { ... }"
        },
        {
          "function": "EqualFunc",
          "description": "Compares maps using custom equality function for values",
          "impact": "new",
          "example": "maps.EqualFunc(m1, m2, func(v1, v2 Type) bool { ... })"
        }
      ],
      "cmp": [
        {
          "function": "Compare",
          "description": "New package for comparison utilities - compares two ordered values",
          "impact": "new",
          "example": "result := cmp.Compare(a, b) // returns -1, 0, or 1"
        },
        {
          "function": "Less",
          "description": "Reports whether x is less than y",
          "impact": "new",
          "example": "if cmp.Less(x, y) { ... }"
        },
        {
          "description": "Ordered type constraint for comparable types",
          "impact": "new",
          "example": "func Min[T cmp.Ordered](a, b T) T { ... }"
        }
      ],
      "log/slog": [
        {
          "description": "New structured logging package with levels and key-value pairs",
          "impact": "new",
          "example": "slog.Info(\"user login\", \"user\", \"alice\", \"duration\", time.Since(start))"
        },
        {
          "function": "Debug",
          "description": "Logs debug level message with optional key-value pairs",
          "impact": "new",
          "example": "slog.Debug(\"processing request\", \"id\", requestID)"
        },
        {
          "function": "Info",
          "description": "Logs info level message with optional key-value pairs",
          "impact": "new",
          "example": "slog.Info(\"server started\", \"port\", 8080)"
        },
        {
          "function": "Warn",
          "description": "Logs warning level message with optional key-value pairs",
          "impact": "new",
          "example": "slog.Warn(\"deprecated API used\", \"endpoint\", \"/old-api\")"
        },
        {
          "function": "Error",
          "description": "Logs error level message with optional key-value pairs",
          "impact": "new",
          "example": "slog.Error(\"database connection failed\", \"error\", err)"
        },
        {
          "function": "With",
          "description": "Returns logger with additional key-value pairs for context",
          "impact": "new",
          "example": "logger := slog.With(\"component\", \"auth\")"
        }
      ],
      "testing/slogtest": [
        {
          "description": "New package for validating slog.Handler implementations",
          "impact": "new",
          "example": "// Provides test utilities for structured logging handlers"
        }
      ],
      "context": [
        {
          "function": "WithDeadlineCause",
          "description": "Creates context with deadline and cancellation cause for better error tracking",
          "impact": "new",
          "example": "ctx, cancel := context.WithDeadlineCause(parent, deadline, errors.New(\"timeout reason\"))"
        },
        {
          "function": "WithTimeoutCause",
          "description": "Creates context with timeout and cancellation cause",
          "impact": "new",
          "example": "ctx, cancel := context.WithTimeoutCause(parent, 5*time.Second, errors.New(\"operation timeout\"))"
        },
        {
          "function": "Cause",
          "description": "Returns cancellation cause of context",
          "impact": "new",
          "example": "if cause := context.Cause(ctx); cause != nil { ... }"
        }
      ],
      "errors": [
        {
          "function": "ErrUnsupported",
          "description": "New sentinel error for unsupported operations",
          "impact": "new",
          "example": "if errors.Is(err, errors.ErrUnsupported) { ... }"
        }
      ],
      "reflect": [
        {
          "function": "TypeFor",
          "description": "Returns reflect.Type for generic type parameter",
          "impact": "new",
          "example": "typ := reflect.TypeFor[int]() // equivalent to reflect.TypeOf((*int)(nil)).Elem()"
        }
      ]
    }
  }
]